<HTML><HEAD><TITLE>grok online manual</TITLE></HEAD>
<BODY BGCOLOR=#ffffff>

<A NAME="ga">
<H1>Expression Grammar</H1>

<P>Expressions are used for queries, for defaults of card items, and
for printing expressions into cards. They are set in Database Edit mode;
a normal user does not deal with expressions directly.

<P>Expressions deal with two data types, <I>strings</I> and
<I>numbers</I>.  Expressions or sub-expressions returning strings are
enclosed in braces; expressions or sub-expressions returning numbers are
enclosed in parentheses.  There are many built-in operators and functions;
most of them can be used only in either string or numeric context.

<P>Numbers begin with a numerical digit or a period, and are in
standard integer, floating-point, or exponential notation. String
literals are enclosed in double quotes. Conversions from numbers to
strings use the <TT>%g</TT> format (unless <TT>printf</TT> is used);
conversions from strings to numbers skips leading blanks and converts
like <TT>atof</TT>. Trailing non-numeric characters are ignored.

<P>Expressions are evaluated as they are parsed. This means that all parts of
the expression are evaluated, <TT>?:</TT>, <TT>&amp;&amp;</TT>, and <TT>||</TT>
do not short-circuit.  Reliance on order of evaluation in anything
other than comma and semicolon lists may break in a future release.

<P>In the following tables, <B>n</B> stands for a number or a
numerical expression, and <B>s</B> stands for a literal string or a
string expression. Note that some operators, such as <TT>==</TT> and
<TT>date</TT>, appear in both contexts.

<A NAME="gb">
<H2>Numerical Operations</H2>

<P>Divisions by zero return 1. Arithmetic operators use standard C
precedences. Bit-wise operations operate on 32 bits only.

<P><TABLE WIDTH="100%" CELLPADDING=4 BORDER=0 CELLSPACING=4>
<TR BGCOLOR=#a0a0e0><TH>operator<TH>type<TH>operation
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Number
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>{</TT><B>s</B><TT>}</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>In number context, convert string to a number
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n1</B> <TT>?</TT> <B>n2</B> <TT>:</TT> <B>n3</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>If <B>n1</B> is nonzero, return <B>n2</B>; otherwise, return <B>n3</B>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n1</B> <TT>,</TT> <B>n2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Evaluate both numbers, return second
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>-</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Unary minus
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>!</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Unary boolean NOT
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>~</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Unary bit-wise NOT
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n1</B> <TT>+</TT> <B>n2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Add two numbers
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n1</B> <TT>-</TT> <B>n2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Subtract two numbers
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n1</B> <TT>*</TT> <B>n2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Multiply two numbers
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n1</B> <TT>/</TT> <B>n2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Divide two numbers
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n1</B> <TT>%</TT> <B>n2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Calculate modulo of two numbers
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n1</B> <TT>&amp;</TT> <B>n2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Calculate bit-wise AND of two numbers
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n1</B> <TT>&amp;&amp;</TT> <B>n2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Calculate boolean AND of two numbers
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n1</B> <TT>|</TT> <B>n2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Calculate bit-wise OR of two numbers
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n1</B> <TT>||</TT> <B>n2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Calculate boolean OR of two numbers
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n1</B> <TT>^</TT> <B>n2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Calculate bit-wise XOR of two numbers
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n1</B> <TT>&lt;&lt;</TT> <B>n2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Calculate bit-wise left shift
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n1</B> <TT>&gt;&gt;</TT> <B>n2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Calculate bit-wise right shift
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n1</B> <TT>==</TT> <B>n2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>1 if both numbers are equal, 0 otherwise
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n1</B> <TT>!=</TT> <B>n2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>1 if both numbers are not equal, 0 otherwise
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n1</B> <TT>&lt;</TT> <B>n2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>1 if <B>n1</B> is less than <B>n2</B>, 0 otherwise
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n1</B> <TT>&gt;</TT> <B>n2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>1 if <B>n1</B> is greater than <B>n2</B>, 0 otherwise
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n1</B> <TT>&lt;=</TT> <B>n2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>1 if <B>n1</B> is less than or equal to <B>n2</B>, 0 otherwise
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n1</B> <TT>&gt;=</TT> <B>n2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>1 if <B>n1</B> is greater than or equal to <B>n2</B>, 0 otherwise
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>abs(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Absolute value of a number
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>int(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>A number truncated to a whole integer
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>sqrt(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Square root of a number
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>exp(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Exponential function, <I>e</I><SUP><B>n</B></SUP>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>log(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Decimal logarithm, log<SUB>10</SUB>&nbsp;<B>n</B>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>ln(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Natural logarithm, log<SUB>e</SUB>&nbsp;<B>n</B>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>pow(</TT><B>n1</B>, <B>n2</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n1</B><SUP><B>n2</B></SUP>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>sin(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Sine of a number, sin&nbsp;<B>n</B>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>cos(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Cosine of a number, cos&nbsp;<B>n</B>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>tan(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Tangent of a number, tan&nbsp;<B>n</B>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>asin(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Arc sine of a number, sin<SUP>-1</SUP>&nbsp;<B>n</B>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>acos(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Arc cosine of a number, cos<SUP>-1</SUP>&nbsp;<B>n</B>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>atan(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Arc tangent of a number, tan<SUP>-1</SUP>&nbsp;<B>n</B>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>atan2(</TT><B>n</B>, <B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Quadrant-aligned arc tangent
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>len(</TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Length of a string
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>#</TT><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Length of a string
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>bound(</TT><B>n</B>, <B>n</B>, <B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n1</B> bounded by a minimum (second number) and a maximum (third number)
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>random</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>A random number in the range of [0.0, 1.0]
</TABLE>

<A NAME="gc">
<H2>String Operations</H2>

<P>Note that string comparisons return strings, and must be enclosed
in braces <TT>{...}</TT> if <TT>&amp;&amp;</TT> or <TT>||</TT> or other
numerical operators are used on the result.

<P>Regular expressions are QRegularExpression objects, which claim to
be identical to those described <A HREF="http://pcre.org/pcre.txt">here</A>.

<P><TABLE WIDTH="100%" CELLPADDING=4 BORDER=0 CELLSPACING=4>
<TR BGCOLOR=#a0a0e0><TH>operator<TH>type<TH>operation
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>{</TT><B>s</B><TT>}</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>String
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>In string context, convert number to a string
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s1</B> <TT>;</TT> <B>s2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Evaluate both strings, return second
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s1</B> <TT>.</TT> <B>s2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Concatenate strings
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s1</B> <TT>?</TT> <B>s2</B> <TT>:</TT> <B>s3</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>If the numeric value of <B>s1</B> is nonzero, return <B>s2</B>; otherwise, return <B>s3</B>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s1</B> <TT>==</TT> <B>s2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return <TT>"1"</TT> if the two strings match; otherwise, return <TT>"0"</TT>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s1</B> <TT>!=</TT> <B>s2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return <TT>"1"</TT> if the two strings do not match; otherwise, return <TT>"0"</TT>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s1</B> <TT>&lt;</TT> <B>s2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return <TT>"1"</TT> if <B>s1</B> is lexicographically less than <B>s2</B>; otherwise, return <TT>"0"</TT>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s1</B> <TT>&gt;</TT> <B>s2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return <TT>"1"</TT> if <B>s1</B> is lexicographically greater than <B>s2</B>; otherwise, return <TT>"0"</TT>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s1</B> <TT>&lt;=</TT> <B>s2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return <TT>"1"</TT> if <B>s1</B> is lexicographically less than or equal to <B>s2</B>; otherwise, return <TT>"0"</TT>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s1</B> <TT>&gt;=</TT> <B>s2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return <TT>"1"</TT> if <B>s1</B> is lexicographically greater than or equal to <B>s2</B>; otherwise, return <TT>"0"</TT>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s1</B> <TT>in</TT> <B>s2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return <TT>"1"</TT> if <B>s1</B> is contained in <B>s2</B>; otherwise, return <TT>"0"</TT>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s1</B> <TT>=~</TT> <B>s2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return <TT>"1"</TT> if <B>s1</B> matches the regular expression pattern <B>s2</B>; otherwise, return <TT>"0"</TT>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s1</B> <TT>!~</TT> <B>s2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return <TT>"1"</TT> if <B>s1</B> does not match the regular expression pattern <B>s2</B>; otherwise, return <TT>"0"</TT>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>chop(</TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return the string with the trailing newline, if any, removed
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>substr(</TT><B>s</B>, <B>n1</B>, <B>n2</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return a substring of <B>s</B>. <B>n1</B> is the start offset and <B>n2</B> the length. A negative offset counts from the end.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>printf(</TT><I>args</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Format and return a string; <I>args</I> is a comma-separated list of expressions. Compound expressions must be enclosed in <TT>(&nbsp;)</TT> or <TT>{&nbsp;}</TT>.  The first argument is a format string like C's printf.  Percent escapes with unsupported features (e.g. <TT>%</TT><I>n</I><TT>$</TT>), formats (e.g. <TT>p</TT>, <TT>n</TT>), field specifiers (e.g. <T>*</T>, <T>*</T><I>n</I><TT>$</TT>) and modifiers (anything but <TT>l</TT>) are ignored (copied directly to the output); this may cause following escapes to select the wrong argument.  Missing arguments are blank/zero.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>tr(</TT><B>s1</B><TT>, </TT><B>s2</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Transform characters in <B>s1</B> according to substitutions in <B>s2</B>.  <B>s2</B> consists of space-separated <B>c</B><TT>=</TT><B>s</B> expressions; all occurrences of <B>c</B> will be replaced by <B>s</B>.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>bsub(</TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Interpret backslash-escapes in <B>s</B>.  Octal escapes (<TT>\nnn</TT>), <TT>\n</TT>, <TT>\r</TT>, and <TT>\t</TT> are as with C.  All others directly escape the next character.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>sub(</TT><B>s1</B><TT>, </TT><B>s2</B><TT>, </TT><B>s3</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return <B>s1</B>, with the first match of the regular expression <B>s2</B> replaced by <B>s3</B>.  <B>s3</B> may have <TT>\0</TT> .. <TT>\9</TT> and <TT>\{</TT><I>n</I><TT>}</TT> to insert subexpressions (0 is the entire match); any other backslash escapes the next character.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>gsub(</TT><B>s1</B><TT>, </TT><B>s2</B><TT>, </TT><B>s3</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return <B>s1</B>, with all matches of the regular expression in <B>s2</B> replaced by <B>s3</B>.  <B>s3</B> may have <TT>\0</TT> .. <TT>\9</TT> and <TT>\{</TT><I>n</I><TT>}</TT> to insert subexpressions (0 is the entire match); any other backslash escapes the next character.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>match(</TT><B>s1</B><TT>, </TT><B>s2</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B>, <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return the offset in <B>s1</B>, plus one, of the first occurrence of the regular expression pattern specified by <B>s2</B>.  Match failure returns 0.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>esc(</TT><B>s1</B><TT>, </TT><B>s2</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Returns <B>s1</B>, with any characters in <B>s2</B> prefixed by the first character in <B>s2</B>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>detab(</TT><B>s</B><TT>, </TT><B>n1</B><TT>, </TT><B>n2</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Expands tabs to spaces in <B>s</B>.  The second and third arguments are optional.  <B>n1</B> is the starting offset from the beginninf of the line of the first character (0 if unspecified).  <B>n2</B> is the tab stop (8 if unspecified).
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>align(</TT><B>s1</B><TT>, </TT><B>n1</B><TT>, </TT><B>s2</B><TT>, </TT><B>n2</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Align <B>s1</B> in a field of width <B>n1</B>.  The third and fourth arguments are optional.  The first character of <B>s2</B> is used to fill in when widening (space if <B>s2</B> is blank or missing).  <B>n2</B> controls the location of the string within the field:  less than zero (default) for left-aligned, greater than zero for right-aligned, and zero for centered.  Note that cursor movement controls (e.g. backspace) count towards the width like any other character.
</TABLE>


<A NAME="gd">
<H2>Variables</H2>

<P>Variables are letters <TT>a</TT> through <TT>z</TT> and <TT>A</TT>
through <TT>Z</TT> that can hold strings or numbers. When a variable is
assigned to, the result of the assignment is returned. All variables
<TT>a</TT>...<TT>z</TT> are reset to the empty string (or 0) when a
database is loaded from disk; variables <TT>A</TT>...<TT>Z</TT> are
never automatically cleared.  In essence, the <TT>A</TT>...<TT>Z</TT>
are globals, and <TT>a</TT>...<TT>z</TT> are local to the database
(i.e., the data, not the form).  When multiple databases are loaded at
once, each database has its own, separate <TT>a</TT>...<TT>z</TT>
variables.

<P><TABLE WIDTH="100%" CELLPADDING=4 BORDER=0 CELLSPACING=4>
<TR BGCOLOR=#a0a0e0><TH>operator<TH>type<TH>operation
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>var</I> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B>,<B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Value of a variable
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>var</I> <TT>=</TT> <B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Assign string value to a variable
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>var</I> <TT>=</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Assign numeric value to a variable
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>var</I> <TT>.=</TT> <B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Append string to a variable
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>var</I> <TT>+=</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Add a number to a variable
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>var</I> <TT>-=</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Subtract a number from a variable
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>var</I> <TT>*=</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Multiply a variable by a number
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>var</I> <TT>/=</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Divide a variable by a number
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>var</I> <TT>%=</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Assign modulo with a number to variable
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>var</I> <TT>&amp;=</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Perform logical AND with a variable
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>var</I> <TT>|=</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Perform logical OR with a variable
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>var</I><TT>++</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Post-increment variable
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>var</I><TT>--</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Post-decrement variable
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>++</TT><I>var</I> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Pre-increment variable
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>--</TT><I>var</I> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Pre-decrement variable
</TABLE>

<A NAME="ge">
<H2>Database Access</H2>

<P>Database rows (cards) can be accessed by providing an index
in brackets. Without brackets, the current card (<TT>this</TT>) is
assumed. Database columns are named. The name must always be prefixed with
an underscore (_). In place of the name, the field can be selected with a
column number (which must also be prefixed with an underscore), beginning
at 0. Only fields that store data in the database can be accessed
(types <I>Input</I>, <I>Time</I>, <I>Flag</I>, and <I>Choice</I>);
this excludes fields of type <I>Label</I> and <I>Print</I>. Fields
can also be assigned to using the ``<TT>=</TT>'' sign; the assignment
returns the assigned value. Avoid assigning to fields in default and
Print and other expressions that are evaluated when redrawing the card;
the card is not re-redrawn if the redrawing itself changed it. It is
recommended to use field assignments only in button action expressions.

<P>The <TT>avg</TT>, <TT>dev</TT>, <TT>min</TT>, <TT>max</TT>, and
<TT>sum</TT> operators differ from all other operators: they don't
reference a field in the current or any single card, they operate on a
field in all cards by accessing an entire column of the database. These
operators are also available as <TT>qavg</TT>, <TT>qdev</TT>,
<TT>qmin</TT>, <TT>qmax</TT>, and <TT> qsum</TT>, which apply the
calculation only to the result of the last query (i.e., to the cards
displayed in the summary). Finally, the <TT> savg</TT>, <TT>sdev</TT>,
<TT>smin</TT>, <TT>smax</TT>, and <TT>ssum</TT> variations are applied
to all cards in the current section; if there are no sections or if all
sections are selected, all cards are considered.

<P>The <TT>switch</TT> statement is legal only in <I>Action when
pressed</I> expressions for Button-type fields in the form editor. It
does nothing until the button expression evaluation is finished. It
then switches grok to a new form as if the Database pulldown had been
used (see the Editing Forms chapter for details about the difference
between <I>databases</I> and <I>forms</I>). The first argument is the
new form name, the second argument is the query expression or search
string that determines which cards are displayed in the summary
initially. The possible combinations are:

<UL>
<LI><TT>switch("", "")</TT><BR>
	Does nothing.<P>

<LI><TT>switch("", "*")</TT><BR>
	Keep the current form, and put all cards in the summary.<P>

<LI><TT>switch("", "{</TT><I>expr</I><TT>}")</TT><BR>
	Keep the current form, and put all cards in the summary for which
	<I>expr</I> returns something other than 0 or the empty string.<P>

<LI><TT>switch("", "(expr)")</TT><BR>
	Equivalent to the previous, except that the returned string is
	converted to a number, which is checked for nonzero values.<P>

<LI><TT>switch("", "string")</TT><BR>
	Keep the current form, and put all cards in the summary whose
	searchable fields contain <I>string</I>.<P>

<LI><TT>switch("name", "")</TT><BR>
	Switch to form <I>name</I>, and display all cards in the
	summary.<P>

<LI><TT>switch("name", "xxx")</TT><BR>
	Switch to form <I>name</I>, and then perform a query. <TT>xxx</TT>
	stands for any of the above query expressions.<P>

</UL>

<P>Because short-circuiting doesn't work, <TT>switch</TT> can't depend
on a conditional, but its two arguments can. <TT>switch</TT> returns
the empty string, which means that the button won't execute a command
as usual; if this is overridden by appending a semicolon and another
string expression, the command is executed after the database switch. To
execute a script before switching, prepend a <TT>system</TT> statement
and a semicolon to the <TT>switch</TT> statement (the switch is done
after the expression is completely evaluated). To switch back to the
previous form, use the <TT>prevform</TT> statement.

<P><B>Looping</B> over all cards in the database can be performed using
the <TT>foreach</TT> statement. It takes either one or two arguments, both
of which can be either string or numeric expressions. In its one-argument
form, it applies the argument expression to every card in the database.
In its two-argument form, it applies the second argument expression to
all cards that cause the first argument expression to evaluate to true
(nonzero numeric value or string not beginning with ``<TT>f</TT>'' or
``<TT>F</TT>''). For example,

<PRE>
     {(a=0); foreach("{_group == 'f'", "(a++)")}
</PRE>

<P>clears the variable <TT>a</TT> and then applies the expression
<TT>(a++)</TT> to all cards for which <TT>{_group&nbsp;==&nbsp;'f'}</TT>
evaluates to true. The number of cards in group <TT>f</TT> is left in
variable <TT>a</TT>. Note the quotes around the argument expressions;
they must be passed to the <TT> foreach</TT> statement as strings. Like
all strings, they can be put together using expressions, for example
using the ``<TT>.</TT>'' (dot) operator.  Although <TT>foreach</TT>,
like <TT>switch</TT>, can only be used in string expressions it does
not return anything.

<P>A more light-weight method of switching to another dabase is the
use of a database prefix:
<TT>@</TT><I>other-db</I><TT>/</TT><I>query</I><TT>+</TT><I>sort-field</I><TT>:</TT><I>expr</I>.
The parameters are interpreted as follows:

<UL>
<LI><TT>@</TT> <I>other-db</I><BR>
	This is required, and specifies the database to use.
	<I>other-db</I> is a string expression which is parsed and
	evaluated in the context of the current database.  It names a
	database in the same way as the database name command-line
	parameter:  either a relative or absolute path to the form
	definition file.
<LI><TT>/</TT> <I>query</I><BR>
	This is optional, and specifies the initial query applied to the
	new database.  It is only relevant for functions which use
	the current query results, such as <TT>qsum</TT>.  If not specified,
	the form's default search is performed, instead.  <I>query</I>
	is a string expression which is parsed and evaluated in the
	context of the current database, but then the contents of the
	string are parsed and evaluated as a query in the context of
	<I>other-db</I>.
<LI><TT>+</TT> <I>sort-field</I><BR>
	This is optional, and specifies the sort order applied to the
	new database.  The <TT>+</TT> may be replaced by a
	<TT>-</TT> for descending order rather than ascending.  More than
	one may be present.  If more than one is given, the database will
	be sorted by all given fields in the given order.  It is only
	relevant for functions which use the current sort order, such
	as <TT>foreach</TT>.  If not specified, the form's default sort
	field is sorted in ascending order.  <I>sort-field</I> is a
	string expression which is parsed and evaluated in the context
	of the current database, but the contents of the string are a
	field name or column number in the new database, optionally
	prefixed by an underscore.
<LI><TT>:</TT> <I>expr</I><BR>
	This is required.  The <TT>:</TT> marks the beginning of an
	expression parsed and evaluated in the context of the new
	database.  This means that field names refer to fields in the
	new database, and the variables a-z refer to variables which are
	local to the new database.  To pass values back to the old
	context, either use global variables A-Z or simply return
	the value desired.  Unlike <TT>foreach</TT>, the <TT>@</TT>
	operator returns the result of evaluating <I>expr</I>.  The
	<I>expr</I> is terminated by the end of expression or a
	comma or semicolon at the same nesting level.  For clarity, it
	may be a good idea to enclose <I>expr</I> in curly braces.
	Note that anything referencing the current card or section
	(e.g. <TT>disp</TT>, <TT>ssum</TT>) will work unpredictably.
</UL>

<PRE>
   b=@"biblio"+"Date"-"Title":{t="";foreach("t.=_Date.' '._Title.bsub('\n')");t}
</PRE>

This sorts biblio by date and then in reverse title order and returns
the list of dates and titles in <TT>b</TT>.  <TT>t</TT> is not
affected in any database but biblio.

<P><TABLE WIDTH="100%" CELLPADDING=4 BORDER=0 CELLSPACING=4>
<TR BGCOLOR=#a0a0e0><TH>operator<TH>type<TH>operation
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>_field</I> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B>,<B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>A field from the database, current card
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>_field</I><TT>[</TT><B>n</B><TT>]</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0> <B>s</B>,<B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>A field from the database, any card
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>_field</I> <TT>=</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Change a field in the database, current card
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>_field</I> <TT>=</TT> <B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Change a field in the database, current card
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>_field</I><TT>[</TT><B>n</B><TT>] =</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0> Change a field in the database, any card
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>_field</I><TT>[</TT><B>n</B><TT>] =</TT> <B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0> Change a field in the database, any card
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>expand(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>A field from the database, current card, with flag or choice value expanded to mnemonic string
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>expand(</TT><I>_field</I><TT>[</TT><B>n</B><TT>])</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0> <B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>A field from the database, any card, with flag or choice value expanded to mnemonic string
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>this</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The number of the current card, 0 is first
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>last</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The number of the last card, 0 is first
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>disp</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The number of the currently displayed card, or -1 if none
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>avg(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Average of a field in all cards
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>qavg(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Average the current query result
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>savg(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Average the current section
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>dev(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Standard deviation of a field in all cards
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>qdev(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Std. dev. of the current query result
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>sdev(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Std. dev. of the current section
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>min(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Minimum value of a field in all cards
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>qmin(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Minimum of the current query result
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>smin(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Minimum of the current section
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>max(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Maximum value of a field in all cards
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>qmax(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Maximum value of the current query result
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>smax(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Maximum value of the current section
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>sum(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Sum of a field in all cards
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>qsum(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Sum of the current query result
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>ssum(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Sum of the current section
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>dbase</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The name of the accessed database file
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>form</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The name of the accessed form file
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>section</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The name of the current section, or the empty string
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>section</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The number of the section the current card is in, or 0
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>section[</TT><B>n</B><TT>]</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The name of section <B>n</B>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>section[</TT><B>n</B><TT>]</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The number of the section card <B>n</B> is in, or 0
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>prevform</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The name of the previous accessed form file
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>switch(</TT><B>s1</B>, <B>s2</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Database switch and/or query; see above
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>foreach(</TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Apply expression to all cards; see above
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>foreach(</TT><B>s1</B><TT>,</TT> <B>s2</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Apply expression to all matching cards; see above
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>@</TT><B>s1</B> <TT>/</TT><B>s2</B> <TT>+</TT><B>s3</B> <TT>:</TT> <B>s4</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Parse, evaluate and return <B>s4</B> as if it appeared in database named by <B>s1</B>, with default query <B>s2</B> and sorted by <B>s3</B>.  See above.
</TABLE>


<A NAME="gf">
<H2>Operating System Access</H2>

<P><TABLE WIDTH="100%" CELLPADDING=4 BORDER=0 CELLSPACING=4>
<TR BGCOLOR=#a0a0e0><TH>operator<TH>type<TH>operation
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>system(</TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Execute a shell command and return the result as a string
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>$</TT><I>envvar</I> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return the value of the environment variable <I>envvar</I>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>host</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The host name of the local host
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>user</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The user's login name
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>uid</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The user's numeric user ID
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>gid</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The user's numeric group ID
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>access(</TT><B>s</B>, <B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>1 if the file name exists (if the number is 0), or if it can be accessed for execution (1), writing (2), and/or reading (4). See access(3).
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>beep</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Ring the terminal bell, return a null string
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>error(</TT><I>args</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Format a string like <TT>printf</TT>, print it in a window, return a null string
</TABLE>

<A NAME="gg">
<H2>Time Conversion</H2>

<P>Dates and times are stored as number of seconds since January 1,
1970. Durations are stored as number of seconds. Note that this means
that a time is a significantly larger number than a duration, even if both
have the same hh:mm string representation. The representation depends
on the date and time format selected in the Preferences menu. A date or
time of exactly 0 (January 1, 1970, 0:00 GMT) is converted to the empty
string; this convention is useful for blank date fields.

<P><TABLE WIDTH="100%" CELLPADDING=4 BORDER=0 CELLSPACING=4>
<TR BGCOLOR=#a0a0e0><TH>operator<TH>type<TH>operation
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>time</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The current time as hh:mm or hh:mm[ap] string
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>time(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Extract time part of the number, and format as hh:mm or hh:mm[ap] string
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>time(</TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Convert a time string to a number of seconds
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>date</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Today's date as dd.mm.yy or mm/dd/yy string
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>date</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Current time in seconds since January 1, 1970
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>date(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Extract date part of the number, and format as dd.mm.yy or mm/dd/yy string
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>date(</TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Convert a date or date/time string to a number of seconds
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>duration(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Convert a number of seconds to a hh:mm string
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>duration(</TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Convert a duration string to a number of seconds
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>year(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Extract the (four-digit) year from a time
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>month(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Extract the month 1..12 from a time
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>day(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Extract the day 1..31 from a time
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>hour(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Extract the hour 0..23 from a time
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>minute(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Extract the minute 0..59 from a time
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>second(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Extract the second 0..59 from a time
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>julian(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Extract the julian date 0..365 from a time
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>leap(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>1 if the time is in a leap year, or 0 otherwise
</TABLE>

<A NAME="gi">
<H2>Array Operations</H2>

<P>Strings can be interpreted as arrays of strings, with array elements
separated by a delimiter.  Occurrences of the delimiter within element
values must also be escaped, along with the escape character itself.
The following functions support this interpretation.  Each form has a
global array delimiter (by default a vertical bar (<TT>|</TT>) and a
global array element escape character (by default the backslash
(<TT>\</TT>).  The delimiter and escape characters must be different
from each other, or else it would be impossible to represent empty
array elements.

<P>Reading array elements outside of its boundaries returns an empty
value.  Reading from negative array indicies counts from past the end
of the array (i.e., -1 is the last element).  Writing to array
elements past the end fills missing values with blanks.  Writing to
any negative index appends to the end (regardless of the actual
negative value).  Note that appending to an empty string sets element
1, not element 0, since an empty string is interpreted as an array of
one blank value.

<P>Arrays always grow or stay the same size when writing to them.
Shrinking can be done using slices (double dot operators).

<P>An array may also be further restricted by calling it a set.  An
empty set is an empty string, i.e. a one-element array whose only
element is blank.  A non-empty set is an array with no blank or
repeated elements, and whose elements are sorted in a system-defined
sort order.  In addition, all elements must be minimally escaped; that
is, the escape character may only be used to escape the escape
character and the separator character.  Note that performing set
operations on an invalid set has unpredictable, likely invalid
results.  A set containing a single element can be created using
<TT>esc(</TT><B>s</B><TT>)</TT>, or just the string itself if it is
already known to be properly escaped.  This can then be added or
removed from a set using the union and difference operators, and
tested for using the intersection, followed by a comparison to the
empty string:

<BLOCKQUOTE>
Add a single element <B>e</B> to set <B>s</B> if not already present:<BR>
<B>s</B><TT> |+ esc(</TT><B>e</B><TT>)</TT><BR>
Remove a single element <B>e</B> from set <B>s</B> if present:<BR>
<B>s</B><TT> |- esc(</TT><B>e</B><TT>)</TT><BR>
Test for presence of a element <B>e</B> in set <B>s</B>:<BR>
<B>s</B><TT> |* esc(</TT><B>e</B><TT>) != ""</TT>
</BLOCKQUOTE>

<P><TABLE WIDTH="100%" CELLPADDING=4 BORDER=0 CELLSPACING=4>
<TR BGCOLOR=#a0a0e0><TH>operator<TH>type<TH>operation
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>esc(</TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B>, <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Returns <B>s</B> with all array delimiters and escape characters prefixed by the array escape character.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>##</TT><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B>, <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The number of elements in array <B>s</B>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B><TT>[</TT><B>n</B><TT>]</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Array element <B>n</B> of array <B>s</B>, properly unescaped.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B><TT>[</TT><B>n1</B> <TT>..</TT> <B>n2</B><TT>]</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>An array of elements from <B>s</B>, starting at <B>n1</B> and ending at <B>n2</B>, inclusive.  Either <B>n1</B> or <B>n2</B> may be ommitted (but not both) to indicate the start or end, respectively.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B><TT>[</TT> <TT>..</TT> <TT>]</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Array <B>s</B> with trailing blank elements removed.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B><TT>[</TT><B>n</B><TT>]</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Array element <B>n</B> of array <B>s</B>, properly unescaped.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s1</B><TT>[</TT><B>n</B><TT>] -&gt; </TT><B>s2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Returns the array <B>s1</B> with the element <B>n</B> replaced by <B>s2</B>, properly escaped.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>foreach(</TT><I>var</I><TT>, </TT><B>s1</B><TT>, </TT><B>s2</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Evaluate expression <B>s2</B> for every array element in <B>s1</B>, assigning the unescaped element to <I>var</I> before evaluation.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>foreach(</TT><I>var</I><TT>, +</TT><B>s1</B><TT>, </TT><B>s2</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Evaluate expression <B>s2</B> for every non-blank array element in <B>s1</B>, assigning the unescaped element to <I>var</I> before evaluation.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>foreach(</TT><I>var</I><TT>, </TT><B>s1</B><TT>, </TT><B>s2</B><TT>, </TT><B>s3</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Evaluate expression <B>s3</B> for every array element in <B>s1</B> for which expression <B>s2</B> evaluates to true, assigning the unescaped element to <I>var</I> before either evaluation.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>foreach(</TT><I>var</I><TT>, +</TT><B>s1</B><TT>, </TT><B>s2</B><TT>, </TT><B>s3</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Evaluate expression <B>s3</B> for every non-blank array element in <B>s1</B> for which expression <B>s2</B> evaluates to true, assigning the unescaped element to <I>var</I> before either evaluation.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>toset(</TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Returns array <B>s</B> converted into a valid set.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s1</B> <TT>|+</TT> <B>s2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The union of the elements in the operand sets.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s1</B> <TT>|*</TT> <B>s2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The intersection of the elements in the operand sets.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s1</B> <TT>|-</TT> <B>s2</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>A set containing elements in the <B>s1</B> but not in <B>s2</B>.
</TABLE>


<A NAME="gh">
<H2>Examples</H2>

<P>For an action when pressed, if you want to pass arguments and run
scripts etc, here is an example of a way of writing something in the
``action when pressed'' field. (It must be entered on a single line.) Note
the blanks that separate arguments.

<PRE>
     {"/bin/mailmaker \""._receipt."\" \""._senton."\" \""._partxofy."\"; xterm -geometry 85x38+109+7 -e /bin/mailsend"}
</PRE>

<P>In this example, Mailmaker is a script that takes the <I>_receipt</I>,
<I>_senton</I>, and <I>_partxofy</I> fields as arguments and composes
an email with headers and body.  mailsend is a script that takes the
headers and body and sends it out; it runs in an xterm so it can ask you
if you really want to send that mail. (This example was contributed by
Pawan &lt;pawan@generalogic.com&gt;).

</BODY></HTML>
