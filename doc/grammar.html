<HTML><HEAD><TITLE>grok online manual</TITLE></HEAD>
<BODY BGCOLOR=#ffffff>

<A NAME="ga">
<H1>Expression Grammar</H1>

<P>Expressions are used for queries, for defaults of card items, and
for printing expressions into cards. They are set in Database Edit mode;
a normal user does not deal with expressions directly.

<P>Expressions deal with two data types, <I>strings</I> and
<I>numbers</I>.  Expressions or sub-expressions returning strings are
enclosed in braces; expressions or sub-expressions returning numbers are
enclosed in parentheses.  There are many built-in operators and functions;
most of them can be used only in either string or numeric context.

<P>Numbers begin with a numerical digit or a period, and are in
standard integer, floating-point, or exponential notation. String
literals are enclosed in double quotes. Conversions from numbers to
strings use the <TT>%g</TT> format (unless <TT>printf</TT> is used);
conversions from strings to numbers skips leading blanks and converts
like <TT>atof</TT>. Trailing non-numeric characters are ignored.

<P>Expressions are interpreted, not compiled. This means that all parts of
the expression are evaluated, <TT>?:</TT>, <TT>&amp;&amp;</TT>, and <TT>||</TT>
do not short-circuit.

<P>In the following tables, <B>n</B> stands for a number or a
numerical expression, and <B>s</B> stands for a literal string or a
string expression. Note that some operators, such as <TT>==</TT> and
<TT>date</TT>, appear in both contexts.

<A NAME="gb">
<H2>Numerical Operations</H2>

<P>Divisions by zero return 1. Arithmetic operators use standard C
precedences. Bit-wise operations operate on 32 bits only.

<P><TABLE WIDTH="100%" CELLPADDING=4 BORDER=0 CELLSPACING=4>
<TR BGCOLOR=#a0a0e0><TH>operator<TH>type<TH>operation
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Number
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>{</TT><B>s</B><TT>}</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>In number context, convert string to a number
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TT>?</TT> <B>n</B> <TT>:</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>If the first number is nonzero, return the second number; otherwise, return the third number
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TT>,</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Evaluate both numbers, return second
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>-</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Unary minus
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>!</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Unary boolean NOT
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>~</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Unary bit-wise NOT
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TT>+</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Add two numbers
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TT>-</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Subtract two numbers
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TT>*</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Multiply two numbers
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TT>/</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Divide two numbers
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TT>%</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Calculate modulo of two numbers
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TT>&amp;</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Calculate bit-wise AND of two numbers
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TT>&amp;&amp;</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Calculate boolean AND of two numbers
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TT>|</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Calculate bit-wise OR of two numbers
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TT>||</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Calculate boolean OR of two numbers
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TT>^</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Calculate bit-wise XOR of two numbers
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TT>&lt;&lt;</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Calculate bit-wise left shift
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TT>&gt;&gt;</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Calculate bit-wise right shift
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TT>==</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>1 if both numbers are equal, 0 otherwise
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TT>!=</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>1 if both numbers are not equal, 0 otherwise
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TT>&lt;</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>1 if the first number is less than the second, 0 otherwise
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TT>&gt;</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>1 if the first number is greater than the second, 0 otherwise
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TT>&lt;=</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>1 if the first number is less than or equal to the second, 0 otherwise
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TT>&gt;=</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>1 if the first number is greater than or equal to the second, 0 otherwise
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>abs(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Absolute value of a number
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>int(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>A number truncated to a whole integer
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>sqrt(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Square root of a number
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>exp(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Exponential function, <I>e<SUP>n</SUP></I>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>log(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Decimal logarithm, log<SUB>10</SUB>&nbsp;<I>n</I>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>ln(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Natural logarithm, log<SUB>e</SUB>&nbsp;<I>n</I>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>pow(</TT><B>n</B>, <B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>First number raised to the second, <I>n<SUP>m</SUP></I>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>sin(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Sine of a number, sin&nbsp;<I>x</I>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>cos(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Cosine of a number, cos&nbsp;<I>x</I>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>tan(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Tangent of a number, tan&nbsp;<I>x</I>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>asin(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Arc sine of a number, sin<SUP>-1</SUP>&nbsp;<I>x</I>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>acos(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Arc cosine of a number, cos<SUP>-1</SUP>&nbsp;<I>x</I>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>atan(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Arc tangent of a number, tan<SUP>-1</SUP>&nbsp;<I>x</I>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>atan2(</TT><B>n</B>, <B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Quadrant-aligned arc tangent
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>len(</TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Length of a string
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>#</TT><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Length of a string
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>bound(</TT><B>n</B>, <B>n</B>, <B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The first number bounded by a minimum (second number) and a maximum (third number)
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>random</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>A random number in the range of [0.0, 1.0]
</TABLE>

<A NAME="gc">
<H2>String Operations</H2>

<P>Note that string comparisons return strings, and must be enclosed
in braces <TT>{...}</TT> if <TT>&amp;&amp;</TT> or <TT>||</TT> or other
numerical operators are used on the result.

<P>Regular expressions are QRegularExpression objects, which claim to
be identical to those described <A HREF="http://pcre.org/pcre.txt">here</A>.

<P><TABLE WIDTH="100%" CELLPADDING=4 BORDER=0 CELLSPACING=4>
<TR BGCOLOR=#a0a0e0><TH>operator<TH>type<TH>operation
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>{</TT><B>s</B><TT>}</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>String
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>In string context, convert number to a string
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TT>;</TT> <B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Evaluate both strings, return second
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TT>.</TT> <B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Concatenate strings
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TT>?</TT> <B>s</B> <TT>:</TT> <B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>If the numeric value of the first string is nonzero, return the second string; otherwise, return the third string
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TT>==</TT> <B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return <TT>"1"</TT> if the two strings match; otherwise, return <TT>"0"</TT>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TT>!=</TT> <B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return <TT>"1"</TT> if the two strings do not match; otherwise, return <TT>"0"</TT>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TT>&lt;</TT> <B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return <TT>"1"</TT> if the first string is lexicographically less than the second string; otherwise, return <TT>"0"</TT>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TT>&gt;</TT> <B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return <TT>"1"</TT> if the first string is lexicographically greater than the second string; otherwise, return <TT>"0"</TT>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TT>&lt;=</TT> <B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return <TT>"1"</TT> if the first string is lexicographically less than or equal to the second string; otherwise, return <TT>"0"</TT>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TT>&gt;=</TT> <B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return <TT>"1"</TT> if the first string is lexicographically greater than or equal to the second string; otherwise, return <TT>"0"</TT>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TT>in</TT> <B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return <TT>"1"</TT> if the first string is contained in the second string; otherwise, return <TT>"0"</TT>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TT>=~</TT> <B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return <TT>"1"</TT> if the first string matches the regular expression pattern in the second string; otherwise, return <TT>"0"</TT>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TT>!~</TT> <B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return <TT>"1"</TT> if the first string does not match the regular expression pattern in the second string; otherwise, return <TT>"0"</TT>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>chop(</TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return the string with the trailing newline, if any, removed
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>substr(</TT><B>s</B>, <B>n</B>, <B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return a substring of the first string. The first number is the start index and the second the length. A negative index counts from the end.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>printf(</TT><I>args</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Format and return a string; <I>args</I> is a comma-separated list of expressions. Compound expressions must be enclosed in <TT>(&nbsp;)</TT> or <TT>{&nbsp;}</TT>.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>tr(</TT><B>s</B><TT>, </TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Transform characters in the first string according to substitutions in the second.  The second string consists of space-separated <B>c</B><TT>=</TT><B>s</B> expressions; all occurrences of <B>c</B> will be replaced by <B>s</B>.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>bsub(</TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Interpret backslash-escapes in <B>s</B>.  Octal escapes, n, r, and t are as with C.  All others directly escape the next character.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>sub(</TT><B>s</B><TT>, </TT><B>s</B><TT>, </TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return the first string, with the first match of the regular expression in the second string replaced by the third string.  The third string may have <TT>\0</TT> .. <TT>\9</TT> and <TT>\{</TT><B>n</B><TT>}</TT> to insert subexpressions; any other backslash escapes the next character. 
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>gsub(</TT><B>s</B><TT>, </TT><B>s</B><TT>, </TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return the first string, with all matches of the regular expression in the second string replaced by the third string.  The third string may have <TT>\0</TT> .. <TT>\9</TT> and <TT>\{</TT><B>n</B><TT>}</TT> to insert subexpressions; any other backslash escapes the next character.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>match(</TT><B>s</B><TT>, </TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B>, <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return the offset in the first string, plus one, of the first occurrence of the regular expression pattern specified by the second string.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>esc(</TT><B>s</B><TT>, </TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Returns the first string, with any characters in the second string prefixed by the first character in the second string
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>detab(</TT><B>s</B><TT>, </TT><B>n</B><TT>, </TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Expands tabs to spaces in <B>s</B>.  The second and third arguments are optional.  The second argument is the starting offset from the left of the first character (0 if unspecified).  The third argument is the tab stop (8 if unspecified).
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>align(</TT><B>s</B><TT>, </TT><B>n</B><TT>, </TT><B>s</B><TT>, </TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Align the first string in a field of width specified by first number.  The third and fourth arguments are optional.  The first character of the third argument is used to fill in when widening (space if the argument is blank or missing).  The fourth argument specifies the location of the string within the field:  less than zero (default) for left-aligned, greater than zero for right-aligned, and zero for centered.  Note that cursor movement controls (e.g. backspace) count towards the width like any other character.
</TABLE>


<A NAME="gd">
<H2>Variables</H2>

<P>Variables are letters <TT>a</TT> through <TT>z</TT> and <TT>A</TT>
through <TT>Z</TT> that can hold strings or numbers. When a variable is
assigned to, the result of the assignment is returned. All variables
<TT>a</TT>...<TT>z</TT> are reset to the empty string (or 0) when a
database is loaded from disk; variables <TT>A</TT>...<TT>Z</TT> are
never automatically cleared.

<P><TABLE WIDTH="100%" CELLPADDING=4 BORDER=0 CELLSPACING=4>
<TR BGCOLOR=#a0a0e0><TH>operator<TH>type<TH>operation
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>var</I> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B>,<B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Value of a variable
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>var</I> <TT>=</TT> <B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Assign string value to a variable
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>var</I> <TT>=</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Assign numeric value to a variable
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>var</I> <TT>.=</TT> <B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Append string to a variable
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>var</I> <TT>+=</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Add a number to a variable
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>var</I> <TT>-=</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Subtract a number from a variable
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>var</I> <TT>*=</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Multiply a variable by a number
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>var</I> <TT>/=</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Divide a variable by a number
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>var</I> <TT>%=</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Assign modulo with a number to variable
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>var</I> <TT>&amp;=</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Perform logical AND with a variable
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>var</I> <TT>|=</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Perform logical OR with a variable
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>var</I><TT>++</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Post-increment variable
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>var</I><TT>--</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Post-decrement variable
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>++</TT><I>var</I> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Pre-increment variable
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>--</TT><I>var</I> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Pre-decrement variable
</TABLE>

<A NAME="ge">
<H2>Database Access</H2>

<P>Database rows (cards) can be accessed by providing an index
in brackets. Without brackets, the current card (<TT>this</TT>) is
assumed. Database columns are named. The name must always be prefixed with
an underscore (_). In place of the name, the field can be selected with a
column number (which must also be prefixed with an underscore), beginning
at 0. Only fields that store data in the database can be accessed
(types <I>Input</I>, <I>Time</I>, <I>Flag</I>, and <I>Choice</I>);
this excludes fields of type <I>Label</I> and <I>Print</I>. Fields
can also be assigned to using the ``<TT>=</TT>'' sign; the assignment
returns the assigned value. Avoid assigning to fields in default and
Print and other expressions that are evaluated when redrawing the card;
the card is not re-redrawn if the redrawing itself changed it. It is
recommended to use field assignments only in button action expressions.

<P>The <TT>avg</TT>, <TT>dev</TT>, <TT>min</TT>, <TT>max</TT>, and
<TT>sum</TT> operators differ from all other operators: they don't
reference a field in the current or any single card, they operate on a
field in all cards by accessing an entire column of the database. These
operators are also available as <TT>qavg</TT>, <TT>qdev</TT>,
<TT>qmin</TT>, <TT>qmax</TT>, and <TT> qsum</TT>, which apply the
calculation only to the result of the last query (i.e., to the cards
displayed in the summary). Finally, the <TT> savg</TT>, <TT>sdev</TT>,
<TT>smin</TT>, <TT>smax</TT>, and <TT>ssum</TT> variations are applied
to all cards in the current section; if there are no sections or if all
sections are selected, all cards are considered.

<P>The <TT>switch</TT> statement is legal only in <I>Action when
pressed</I> expressions for Button-type fields in the form editor. It
does nothing until the button expression evaluation is finished. It
then switches grok to a new form as if the Database pulldown had been
used (see the Editing Forms chapter for details about the difference
between <I>databases</I> and <I>forms</I>. The first argument is the
new form name, the second argument is the query expression or search
string that determines which cards are displayed in the summary
initially. The possible combinations are:

<UL>
<LI><TT>switch("", "")</TT><BR>
	Does nothing.<P>

<LI><TT>switch("", "*")</TT><BR>
	Keep the current form, and put all cards in the summary.<P>

<LI><TT>switch("", "{</TT><I>expr</I><TT>}")</TT><BR>
	Keep the current form, and put all cards in the summary for which
	<I>expr</I> returns something other than 0 or the empty string.<P>

<LI><TT>switch("", "(expr)")</TT><BR>
	Equivalent to the previous, except that the returned string is
	converted to a number, which is checked for nonzero values.<P>

<LI><TT>switch("", "string")</TT><BR>
	Keep the current form, and put all cards in the summary whose
	searchable fields contain <I>string</I>.<P>

<LI><TT>switch("name", "")</TT><BR>
	Switch to form <I>name</I>, and display all cards in the
	summary.<P>

<LI><TT>switch("name", "xxx")</TT><BR>
	Switch to form <I>name</I>, and then perform a query. <TT>xxx</TT>
	stands for any of the above query expressions.<P>

</UL>

<P>Because short-circuiting doesn't work, <TT>switch</TT> can't depend
on a conditional, but its two arguments can. <TT>switch</TT> returns
the empty string, which means that the button won't execute a command
as usual; if this is overridden by appending a semicolon and another
string expression, the command is executed after the database switch. To
execute a script before switching, prepend a <TT>system</TT> statement
and a semicolon to the <TT>switch</TT> statement (the switch is done
after the expression is completely evaluated). To switch back to the
previous form, use the <TT>prevform</TT> statement.

<P><B>Looping</B> over all cards in the database can be performed using
the <TT>foreach</TT> statement. It takes either one or two arguments, both
of which can be either string or numeric expressions. In its one-argument
form, it applies the argument expression to every card in the database.
In its two-argument form, it applies the second argument expression to
all cards that cause the first argument expression to evaluate to true
(nonzero numeric value or string not beginning with ``<TT>f</TT>'' or
``<TT>F</TT>''). For example,

<PRE>
     {(a=0); foreach("{_group == 'f'", "(a++)")}
</PRE>

<P>clears the variable <TT>a</TT> and then applies the expression
<TT>(a++)</TT> to all cards for which <TT>{_group&nbsp;==&nbsp;'f'}</TT>
evaluates to true. The number of cards in group <TT>f</TT> is left in
variable <TT>a</TT>. Note the quotes around the argument expressions;
they must be passed to the <TT> foreach</TT> statement as strings. Like
all strings, they can be put together using expressions, for example
using the ``<TT>.</TT>'' (dot) operator.  Although <TT>foreach</TT>,
like <TT>switch</TT>, can only be used in string expressions it does
not return anything.

<P><TABLE WIDTH="100%" CELLPADDING=4 BORDER=0 CELLSPACING=4>
<TR BGCOLOR=#a0a0e0><TH>operator<TH>type<TH>operation
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>_field</I> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B>,<B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>A field from the database, current card
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>_field</I><TT>[</TT><B>n</B><TT>]</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0> <B>s</B>,<B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>A field from the database, any card
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>_field</I> <TT>=</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Change a field in the database, current card
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>_field</I> <TT>=</TT> <B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Change a field in the database, current card
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>_field</I><TT>[</TT><B>n</B><TT>] =</TT> <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0> Change a field in the database, any card
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><I>_field</I><TT>[</TT><B>n</B><TT>] =</TT> <B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0> Change a field in the database, any card
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>expand(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>A field from the database, current card, with flag or choice value expanded to mnemonic string (*)
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>expand(</TT><I>_field</I><TT>[</TT><B>n</B><TT>])</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0> <B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>A field from the database, any card, with flag or choice value expanded to mnemonic string (*)
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>this</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The number of the current card, 0 is first
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>last</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The number of the last card, 0 is first
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>disp</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The number of the currently displayed card, or -1 if none
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>avg(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Average of a field in all cards
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>qavg(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Average the current query result
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>savg(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Average the current section
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>dev(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Standard deviation of a field in all cards
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>qdev(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Std. dev. of the current query result
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>sdev(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Std. dev. of the current section
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>min(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Minimum value of a field in all cards
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>qmin(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Minimum of the current query result
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>smin(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Minimum of the current section
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>max(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Maximum value of a field in all cards
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>qmax(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Maximum value of the current query result
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>smax(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Maximum value of the current section
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>sum(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Sum of a field in all cards
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>qsum(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Sum of the current query result
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>ssum(</TT><I>_field</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Sum of the current section
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>dbase</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The name of the accessed database file
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>form</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The name of the accessed form file
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>section</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The name of the current section, or the empty string
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>section</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The number of the section the current card is in, or 0
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>section[</TT><B>n</B><TT>]</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The name of section <B>n</B>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>section[</TT><B>n</B><TT>]</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The number of the section card <B>n</B> is in, or 0
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>prevform</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The name of the previous accessed form file
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>switch(</TT><B>s</B>, <B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Database switch and/or query; see above
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>foreach(</TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Apply expression to all cards; see above
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>foreach(</TT><B>s</B>, <B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Apply expression to all matching cards; see above
</TABLE>

<P>(*) The <TT>expand</TT> keyword was introduced in grok version 1.5.


<A NAME="gf">
<H2>Operating System Access</H2>

<P><TABLE WIDTH="100%" CELLPADDING=4 BORDER=0 CELLSPACING=4>
<TR BGCOLOR=#a0a0e0><TH>operator<TH>type<TH>operation
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>system(</TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Execute a shell command and return the result as a string
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>$</TT><I>envvar</I> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Return the value of the environment variable <I>envvar</I>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>host</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The host name of the local host
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>user</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The user's login name
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>uid</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The user's numeric user ID
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>gid</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The user's numeric group ID
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>access(</TT><B>s</B>, <B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>1 if the file name exists (if the number is 0), or if it can be accessed for execution (1), writing (2), and/or reading (4). See access(3).
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>beep</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Ring the terminal bell, return a null string
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>error(</TT><I>args</I><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Format a string like printf, print it in a window, return a null string
</TABLE>

<A NAME="gg">
<H2>Time Conversion</H2>

<P>Dates and times are stored as number of seconds since January 1,
1970. Durations are stored as number of seconds. Note that this means
that a time is a significantly larger number than a duration, even if both
have the same hh:mm string representation. The representation depends
on the date and time format selected in the Preferences menu. A date or
time of exactly 0 (January 1, 1970, 0:00 GMT) is converted to the empty
string; this convention is useful for blank date fields.

<P><TABLE WIDTH="100%" CELLPADDING=4 BORDER=0 CELLSPACING=4>
<TR BGCOLOR=#a0a0e0><TH>operator<TH>type<TH>operation
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>time</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The current time as hh:mm or hh:mm[ap] string
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>time(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Extract time part of the number, and format as hh:mm or hh:mm[ap] string
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>time(</TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Convert a time string to a number of seconds
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>date</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Today's date as dd.mm.yy or mm/dd/yy string
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>date</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Current time in seconds since January 1, 1970
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>date(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Extract date part of the number, and format as dd.mm.yy or mm/dd/yy string
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>date(</TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Convert a date or date/time string to a number of seconds
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>duration(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Convert a number of seconds to a hh:mm string
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>duration(</TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Convert a duration string to a number of seconds
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>year(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Extract the (four-digit) year from a time
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>month(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Extract the month 1..12 from a time
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>day(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Extract the day 1..31 from a time
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>hour(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Extract the hour 0..23 from a time
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>minute(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Extract the minute 0..59 from a time
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>second(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Extract the second 0..59 from a time
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>julian(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Extract the julian date 0..365 from a time
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>leap(</TT><B>n</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>1 if the time is in a leap year, or 0 otherwise
</TABLE>

<A NAME="gi">
<H2>Array Operations</H2>

<P>Strings can be interpreted as arrays of strings, with array elements
separated by a delimiter.  Occurrences of the delimiter within element
values must also be escaped, along with the escape character itself.
The following functions support this interpretation.  Each form has a
global array delimiter (by default a vertical bar (<TT>|</TT>) and a
global array element escape character (by default the backslash
(<TT>\</TT>).  The delimiter and escape characters must be different
from each other, or else it would be impossible to represent empty
array elements.

<P>Reading array elements outside of its boundaries returns an empty
value.  Writing to array elements past the end fills missing values
with blanks.  Writing to a negative index appends to the end
(regardless of the actual negative value).  Note that appending to an
empty string sets element 1, not element 0, since an empty string is
interpreted as an array of one blank value.

<P>An array may also be further restricted by calling it a set.  An
empty set is an empty string, i.e. a one-element array whose only
element is blank.  A non-empty set is an array with no blank or
repeated elements, and whose elements are sorted in a system-defined
sort order.  In addition, all elements must be minimally escaped; that
is, the escape character may only be used to escape the escape
character and the separator character.  Note that performing set
operations on an invalid set has unpredictable, likely invalid
results.  A set containing a single element can be created using
<TT>esc(</TT><B>s</B><TT>)</TT>, or just the string itself if it is
already known to be properly escaped.  This can then be added or
removed from a set using the union and difference operators, and
tested for using the intersection, followed by a comparison to the
empty string:

<BLOCKQUOTE>
Add a single element <B>e</B> to set <B>s</B> if not already present:<BR>
<B>s</B><TT> |+ esc(</TT><B>e</B><TT>)</TT><BR>
Remove a single element <B>e</B> from set <B>s</B> if present:<BR>
<B>s</B><TT> |- esc(</TT><B>e</B><TT>)</TT><BR>
Test for presence of a element <B>e</B> in set <B>s</B>:<BR>
<B>s</B><TT> |* esc(</TT><B>e</B><TT>) != ""</TT>
</BLOCKQUOTE>

<P><TABLE WIDTH="100%" CELLPADDING=4 BORDER=0 CELLSPACING=4>
<TR BGCOLOR=#a0a0e0><TH>operator<TH>type<TH>operation
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>esc(</TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B>, <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Returns <B>s</B> with all array delimiters and escape characters prefixed by the array escape character.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>##</TT><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B>, <B>n</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The number of elements in array <B>s</B>
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B><TT>[</TT><B>n</B><TT>]</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Array element <B>n</B> of array <B>s</B>, properly unescaped.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B><TT>[</TT><B>n</B><TT>] -> </TT><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Returns an array which replaces element <B>n</B> in the array specified by the first string with the second string, properly escaped.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0>foreach(<I>var</I><TT>, </TT><B>s</B><TT>, </TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Evaluate the third string for every array element in the second string, assigning the element to <I>var</I> first.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0>foreach(<I>var</I><TT>, +</TT><B>s</B><TT>, </TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Evaluate the third string for every non-blank array element in the second string, assigning the element to <I>var</I> first.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0>foreach(<I>var</I><TT>, </TT><B>s</B><TT>, </TT><B>s</B><TT>, </TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Evaluate the third string for every array element in the third string for which the second string evaluates to true, assigning the element to <I>var</I> first.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0>foreach(<I>var</I><TT>, +</TT><B>s</B><TT>, </TT><B>s</B><TT>, </TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Evaluate the third string for every non-blank array element in the third string for which the second string evaluates to true, assigning the element to <I>var</I> first.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><TT>toset(</TT><B>s</B><TT>)</TT> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>Returns array <B>s</B> converted into a valid set.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TT>|+</TT> <B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The union of the elements in the operand sets.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TT>|*</TT> <B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>The intersection of the elements in the operand sets.
<TR> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TT>|-</TT> <B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0><B>s</B> <TD VALIGN=TOP BGCOLOR=#e0e0e0>A set containing elements in the first set but not in the second.
</TABLE>


<A NAME="gh">
<H2>Examples</H2>

<P>For an action when pressed, if you want to pass arguments and run
scripts etc, here is an example of a way of writing something in the
``action when pressed'' field. (It must be entered on a single line.) Note
the blanks that separate arguments.

<PRE>
     {"/bin/mailmaker \""._receipt."\" \""._senton."\" \""._partxofy."\"; xterm -geometry 85x38+109+7 -e /bin/mailsend"}
</PRE>

<P>In this example, Mailmaker is a script that takes the <I>_receipt</I>,
<I>_senton</I>, and <I>_partxofy</I> fields as arguments and composes
an email with headers and body.  mailsend is a script that takes the
headers and body and sends it out; it runs in an xterm so it can ask you
if you really want to send that mail. (This example was contributed by
Pawan &lt;pawan@generalogic.com&gt;).

</BODY></HTML>
